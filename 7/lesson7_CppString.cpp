//~ ѕоиск подстроки в тексте!!!
//~ Ќапишем программу, котора€ в данной последовательности строк(str1) ищет введенную нами 
//~ строку(str2). ≈сли str2 найдено, то вывести строку(str1), аналогичную первоначальной, 
//~ но вместо найденной str2 отобразить звездочки -- *.
//~ ≈сли слово не найдено, написать "Not found".

#include <iostream>
#include <string>

using namespace std;

int main() {
	//~ 1) –ассматриваем ввод и вывод объектов string
	string str1;
	string str2;
	//~ —начала введем строку, которую ходим найти
	cout << "You will find: " ;
	//~ cin >> str1; -- обычным способом не получитс€ сделать, так как 
	//~ cin считывает до перовго разделител€, т.е. до пробела
	getline(cin, str2);
	cout << "...in the text (division - '$'): " << endl;
	//~ »спользуем getline() -- принимает ввод, который может содержать 
	//~ пробелы и несколько строк
	// ¬ качетсве разделител€ строк используем '$'
	getline(cin, str1,'$');
	
	//~ –ассматриваем поиск объектов
	//~ find() -- возвращает позицию, с которой начинаетс€ совпадение 
	//~ (помним, что нумераци€ строки начинаетс€ с 0)
	//~ “ак как find возвращает одну единственную позиию, а нам нужны все!, 
	//~ то потребуетс€ какой-то иной метод
	
	int n = str1.find(str2); // нашли первое сопадение;
	int len=0;
	string str3="";
	if (n==-1) {
		cout << "Not found! " << endl;
		return 0;
	}
	while((n = str1.find(str2))!=-1) {
		str3="";
		n = str1.find(str2); // нашли первое сопадение
		len = str2.size(); // находим длину исходной строки 
		//~ (есть отличие между размером и длиной строки)
		for (int i=0; i<len; i++)
			str3 += "*";
		str1.replace(n,len,str3); //1-позици€ начала замены, 
		//~ 2ой - сколько элементов должно быть заменено, 3й - строка дл€ замены 
	}
	
	cout <<"\n\nResult:\n" << str1 << endl;
	return 0;
}
