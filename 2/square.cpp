// Программа, которая по заданным числам а, b и с 
// считает корни квадратного уравнения вида: ax^2+bx+c = 0.
// Все ли помнят, как находятся корни квадратного уравнения?
// Продиктуйте кто-нибудь формулу. Пожалуйста.
#include <iostream>
//1st step debug
#include <cmath> // C-ишная матем. библиотека

using namespace std;

int main() {
// 	Введите значения
	cout << "Enter the values of a, b and c with any space:" << endl;
// 	Объявляем наши коэффициенты
	int a=0, b=0, c=0;
/*	Устанавливаем их значение в 0, чтобы не было неопределенностей,
	ведь когда выделяется в памяти какая-то переменная, она имеет только адрес 
	в памяти, значение ее не установлено изначально.*/

// 	Считываем переменные
	cin >> a >> b >> c;
	
// 	Печатаем общий вид нашего уравнения:
	cout << a << "x^2 + " << b << "x + "<< c << " = 0;\n";
// 	использовали вместо endl символ перевода на новую строку
	
// 	Объявляем дискриминант и посчитаем его:
	int D = b*b-4*a*c;
// 	Объявим переменные, в которых будет хранится значение корней
	//3th step debug
	float x1;
	float x2;
// 	Проверяем условия для D
	if (D == 0) { // 2d step debug
			//4th step debug
			x1 = x2 = -b*1.0/(2*a);
	} else {
		if (D<0) {
			cout << "Just complex roots =(" << endl;
			return 0; // выходим из программы
		}
		else { // if D>0
			x1 = (-b-sqrt(D))*1.0/(2*a);
			x2 = (-b+sqrt(D))*1.0/(2*a);
		}
	}
	// Используем табуляцию при выводе
	cout << "x1 = " << x1 << "\tx2 = "<< x2 << endl; 
	
// 	Прежде чем запускать, сначала придумаем тесты, т.е уравнения
// 	для которых сразу можно проверить правильность выполнения:
// 	1. x^2+2*x+1 = 0; root == -1. a = 1; b = 2; c = 1;
// 	2. x^2-5x+6 = 0; roots == 3; 2.; a = 1; b = -5; c = 6;
// 	3. x^2-8x+16 = 0; root = 4. a = 1; b = -8; c = 16;
// 	4. x^2+x+1 = 0; just complex a = 1; b = 1; c =1;
// 	5. 4x^2+4x+1 = 0; root = -0.5; a = 4; b = 4; c=1;
	
	return 0;
}

// Запускаем. Есть ли ошибки компиляции? Если есть, скажите какая?
// 1) not declared-- означает не определен. Это потому, что нужно подключить заголовочный файл, с встроенными
// математическими функциями
// Запускаем и проверяем на наших тестах.
// 2) На первой тесте все ок. На втором -- что-то не так. В программе я злоумышленно сделала ошибку.
// Кто-нибудь ее уже нашел?
// Ошибка в самой первой проверки. Наш компилятор не ругается на это, т.к. мы присвоили d=0, а 0 -- логическая ложь для С++,
// все что != 0 для С++ -- истина. Нужо поставить ==.
// 3) В последнем тесте у нас ошибка. Почему?
// Ответ: типы у x1 & x2 -- целые. исправим это. Запускаем. 
// 4) Ответ у нас не изменился. Все потому, что операция \ --
// операция целочисленного деления и т.к. у нас произошло деление целого на целое, то и результат вернулся целым (вспоминаем
// тему автоматического неявного приведения типов). 
// Поэтому укажем явно, что мы выполняем операции с вещественными числами.

// Делаем вывод: чем больше тестов, тем большая вероятность найти ошибку в коде. 
// Вот как важны тесты при написании любой программы.